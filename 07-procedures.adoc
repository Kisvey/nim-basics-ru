= Процедуры


Процедуры или _функции_, как их называют в некоторых других языках программирования, это части кода, которые выполняют определённую задачу, упакованную в единое целое.
Преимуществом группировки кода таким образом является то, что мы можем _вызывать_ эти процедуры вместо того, чтобы писать весь код заново, когда мы хотим использовать код процедуры.

В некоторых из предыдущих глав мы рассматривали гипотезу Коллатца в различных сценариях.
Обёртывая логику гипотезы Коллатца в процедуру, мы могли бы вызывать один и тот же код для всех упражнений.

На протяжении мы использовали много встроенных процедур, таких как `echo` для печати, `add` для добавления элементов в последовательность, `inc` для увеличения значения целого числа, `len` для получения длины контейнера и т.д.
Теперь мы увидим, как создавать и использовать наши собственные процедуры.

Некоторые преимущества использования процедур:

* Уменьшение дублирования кода
* Упрощение чтения кода, поскольку мы можем называть части по их функционалу
* Разбиение сложной задачи на более простые шаги

Как упоминалось в начале этого раздела, процедуры часто называют функциями в других языках программирования.
Это на самом деле немного неверно, если мы рассмотрим математическое определение функции.
Математические функции принимают набор аргументов (например, `f(x, y)`, где `f` - это функция, а `x` и `y` - её аргументы) и всегда возвращают один и тот же результат для одних и тех же входных данных.

Программные процедуры, с другой стороны, не всегда возвращают один и тот же результат для заданного входа.
Иногда они вообще ничего не возвращают.
Это связано с тем, что наши компьютерные программы могут хранить состояние в переменных, которые мы упоминали ранее, и которые процедуры могут читать и изменять.
В Nim слово `func` зарезервировано для использования как более математически корректный вид функции, который не допускает побочных эффектов.




== Объявление процедуры

Прежде мы чем сможем использовать (вызывать) нашу процедуру, нам нужно её создать и определить, что она делает.

Процедура объявляется с помощью ключевого слова `proc` и имени процедуры, за которым следуют входные параметры и их тип в круглых скобках, а последняя часть - это двоеточие и тип значения, возвращаемого процедурой, вот так:

[source]
----
proc <name>(<p1>: <type1>, <p2>: <type2>, ...): <returnType>
----

Тело процедуры пишется в отступе после объявления с добавленным знаком `=`.

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=1..8]
----
<1> Объявление процедуры с именем `findMax`, которая имеет два параметра, `x` и `y`, и возвращает значение типа `int`.
<2> Чтобы вернуть значение из процедуры, мы используем ключевое слово `return`.


{nbsp}

[source]
----
proc echoLanguageRating(language: string) = <1>
  case language
  of "Nim", "nim", "NIM":
    echo language, " is the best language!"
  else:
    echo language, " might be a second-best language."
----
<1> Процедура `echoLanguageRating` просто выводит заданное имя, она не возвращает ничего, поэтому тип возвращаемого значения не объявляется.


{nbsp}

Обычно мы не можем изменять какие-либо параметры, которые нам передали.
Творение чего-то подобного приведет к ошибке:

[source]
----
proc changeArgument(argument: int) =
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
----

Что бы сделать это возможным, нам нужно разрешить Nim и программисту, использующему нашу процедуру, изменять аргумент, объявив его как переменную:

[source]
----
proc changeArgument(argument: var int) = <1>
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
echo ourVariable
changeArgument(ourVariable)
echo ourVariable
----
<1> Обратите внимание, как `argument` теперь объявлен как `var int`, а не просто как `int`.

[source, output]
----
15
20
----

Это естественно означает что имя, которое мы передаем, также должно быть объявлено как переменная, передача чего-то присвоенного с `const` или `let` вызовет ошибку.

Хорошей практикой является передача аргументов в процедуры, но также возможно использовать имена, объявленные вне процедуры, как переменные, так и константы:

[source]
----
var x = 100

proc echoX() =
  echo x  <1>
  x += 1  <2>

echoX()
echoX()
----
<1> Тут мы обращаемся к внешней переменной `x`.
<2> Мы также можем обновить её значение, поскольку она объявлена как переменная.
[source, output]
----
100
101
----


== Вызов процедуры

После того, как мы объявили процедуру, мы можем её вызвать.
Обычный способ вызова процедур/функций во многих языках программирования - указать её имя и предоставить аргументы в круглых скобках, вот так:

[source]
----
<procName>(<arg1>, <arg2>, ...)
----

Результат от вызова процедуры может быть сохранен в переменной.

Если мы хотим вызвать нашу процедуру `findMax` из приведенного выше примера и сохранить возвращаемое значение в переменной, мы можем сделать это так:

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=10..18]
----
<1> Результат от функции `findMax` здесь называется `c`, и вызывается с результатами наших первых двух вызовов (`findMax(987, 321)`).

[source, output]
----
987
321
987
----

{nbsp}

Nim также, в отличие от многих других языков, поддерживает https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax[Унифицированный синтаксис вызова функций], который позволяет использовать множество различных способов вызова процедур.

Этот вызов похож на обычный вызов процедуры, но первый аргумент записывается перед именем функции и остальные параметры указываются в круглых скобках:

[source]
----
<arg1>.<procName>(<arg2>, ...)
----

Мы использовали этот синтаксис, когда добавляли элементы в существующую последовательность (`<seq>.add(<element>)`), так как это делает его более читаемым и выражает наше намерение более ясно, чем запись `add(<seq>, <element>)`.
Мы также можем опустить круглые скобки вокруг аргументов:

[source]
----
<procName> <arg1>, <arg2>, ...
----

Мы видели этот стиль, когда вызывали процедуру `echo`, и при вызове процедуры `len` без каких-либо аргументов.
Эти два также могут быть объединены вот так, но этот синтаксис, однако, не очень часто используется:

[source]
----
<arg1>.<procName> <arg2>, <arg3>, ...
----


{nbsp}

Унифицированный синтаксис вызова позволяет сделать цепочку из нескольких процедур более читаемой:

[source]
.ufcs.nim
----
include::{source-dir}/ufcs.nim[]
----
<1> Если несколько параметров имеют одинаковый тип, мы можем объявить их тип в этом компактном виде.
<2> Сначала мы складываем `a` и `b`, затем результат этой операции (2 + 3 = 5) передается как первый параметр в процедуру `multi`, где он умножается на `c` (5 * 4 = 20).
<3> Сначала мы умножаем `c` и `b`, затем результат этой операции (4 * 3 = 12) передается как первый параметр в процедуру `plus`, где он складывается с `a` (12 + 2 = 14).

[source, output]
----
true
true
20
14
----




== Переменная result

В Nim, каждая процедура, которая возвращает значение, имеет неявно объявленную и инициализированную (значением по умолчанию) переменную `result`.
Процедура вернет значение этой переменной `result`, когда достигнет конца своего отступленного блока, даже если нет оператора `return`.

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=1..9]
----
<1> Возвращаемый тип `int`. Переменная `result` инициализирована значением по умолчанию для `int`: `0`.
<2> Когда процедура достигает конца своего отступленного блока, возвращается значение переменной `result`.

[source, output]
----
33
----

Обратите внимание, что эта процедура здесь приведена для демонстрации переменной `result`, и она не является на 100% корректной:
если вы передадите последовательность, содержащую только отрицательные числа, эта процедура вернет `0` (что _не_ содержится в последовательности).


{nbsp}


WARNING: Осторожно!
В старых версиях Nim (до Nim 0.19.0) значение по умолчанию для строк и последовательностей было https://en.wikipedia.org/wiki/Null_pointer[`nil`], и когда мы использовали их в качестве возвращаемых типов, переменная `result` должна была быть инициализирована как пустая строка (`""`) или как пустая последовательность (`@[]`).

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=11..20]
----
<1> В версии Nim 0.19.0 и новее эта строка не нужна -- последовательности автоматически инициализируются как пустые последовательности. +
В более старых версиях Nim последовательности должны быть инициализированы, и без этой строки компилятор выдаст ошибку. (Обратите внимание, что `var` не должен использоваться, так как `result` уже объявлен неявно.) 

[source, output]
----
@[1, 43, 57]
----


{nbsp}

Внутри процедуры мы также можем вызывать другие процедуры.

[source]
.filterOdds.nim
----
include::{source-dir}/filterOdds.nim[]
----
<1> Ещё раз, эта строка не нужна в новых версиях Nim.
<2> Вызов ранее объявленной процедуры. Её возвращаемый тип `bool` и может быть использован в условии if.
<3> Третий способ вызова процедуры, как мы видели выше.

[source, output]
----
@[6, 9, 0, 3]
@[3]
@[45390, 3219]
----





== Предварительное объявление 

Как упоминалось в самом начале этого раздела, мы можем объявить процедуру без блока кода.
Причина этого в том, что мы должны объявить процедуры до того, как мы сможем их вызвать, и вот так делать не будет работать:

[source]
----
echo 5.plus(10) # error      <1>

proc plus(x, y: int): int =  <2>
  return x + y
----
<1> Это приведет к ошибке, так как `plus` еще не определена.
<2> Здесь мы определяем `plus`, но так как она определена после её использования, Nim ещё не знает о ней.

Способ обойти это - это то, что называется предварительным объявлением:

[source]
----
proc plus(x, y: int): int    <1>

echo 5.plus(10)              <2>

proc plus(x, y: int): int =  <3>
  return x + y
----
<1> Тут мы говорим Nim, что процедура `plus` существует с таким определением.
<2> Теперь мы можем использовать её в коде, это будет работать.
<3> Это место, где `plus` реализована на самом деле, и она должна соответствовать предыдущему определению.





== Упражнения

1. Создайте процедуру, которая будет приветствовать человека (печатать "Hello <name>") на основе предоставленного имени. Создайте последовательность имен. Приветствуйте каждого человека с помощью созданной процедуры.

2. Создайте процедуру `findMax3`, которая будет возвращать наибольшее из трех значений.

3. Точки на плоскости можно представить как `tuple[x, y: float]`. Напишите процедуру, которая будет получать две точки и возвращать новую точку, которая является суммой этих двух точек (складывая x и y отдельно).
4. Создайте две процедуры `tick` и `tock`, которые будут печатать слова "tick" и "tock". Создайте глобальную переменную для отслеживания количества вызовов, и вызывайте одну процедуру из другой до тех пор, пока счетчик не достигнет 20. Ожидаемый вывод - строки с "tick" и "tock", чередующиеся 20 раз. (Подсказка: используйте предварительное объявление.)

NOTE: Вы можете нажать Ctrl+C, чтобы остановить выполнение программы, если вы ввели бесконечный цикл.

Тестируйте все процедуры, вызывая их с разными параметрами.
