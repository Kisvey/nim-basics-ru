= Контейнеры




Контейнеры это типы данных, которые содержат коллекцию элементов и позволяют нам получить доступ к этим элементам.
Обычно контейнер также является итерируемым, что означает, что мы можем использовать их так же, как строки в главе <<Циклы, Циклы>>.

Например, список покупок - это контейнер элементов, которые мы хотим купить, а список простых чисел - это контейнер чисел.
Написано в псевдокоде:
[source]
----
groceryList = [ham, eggs, bread, apples]
primes = [1, 2, 3, 5, 7]
----



== Массивы

Массив - это самый простой тип контейнера.
Массивы однородны, т.е. все элементы в массиве должны иметь одинаковый тип.
Массивы также имеют постоянный размер, что означает, что количество элементов (или скорее: количество _возможных_ элементов) должно быть известно на этапе компиляции.
Это означает, что мы называем массивы "однородным контейнером постоянной длины".

Тип массива объявляется с помощью `array[<length>, <type>]`, где `length` - это общая емкость массива (количество элементов, которое он может содержать), а `type` - тип всех его элементов.
Объявление может быть опущено, если и длина, и тип могут быть выведены из переданных элементов..

Элементы массива заключены внутри квадратных скобок.

[source]
----
var
  a: array[3, int] = [5, 7, 9]
  b = [5, 7, 9]        <1>
  c = []  # error      <2>
  d: array[7, string]  <3>
----
<1> Если мы предоставляем значения, длина и тип массива `b` известны на этапе компиляции. Хотя это корректно, нет необходимости специально объявлять его как массив `a`.
<2> Ни длина, ни тип элементов не могут быть выведены из этого типа объявления -- это приводит к ошибке.
<3> Правильный способ объявить пустой массив (который будет заполнен позже) - это указать его длину и тип, не предоставляя значения его элементов -- массив `d` может содержать семь строк.

Так как длина массива должна быть известна на этапе компиляции, это не сработает:

[source]
----
const m = 3
let n = 5

var a: array[m, char]
var b: array[n, char] # error <1>
----
<1> Это приводит к ошибке, потому что `n` объявлен с помощью `let` -- его значение неизвестно на этапе компиляции. Мы можем использовать только значения, объявленные с помощью `const`, как параметр `length` для инициализации массива.





== Последовательность

Последовательности - это контейнеры, похожие на массивы, но их длина не обязательно должна быть известна на этапе компиляции, и она может изменяться во время выполнения: мы объявляем только тип содержащихся элементов с помощью `seq[<type>]`.
Последовательности также являются однородными, т.е. каждый элемент в последовательности должен быть одного типа.

Элементы последовательности заключены между `@[` и `]`.

[source]
----
var
  e1: seq[int] = @[]   <1>
  f = @["abc", "def"]  <2>
----
<1> Тип пустой последовательности должен быть объявлен.
<2> Тип непустой последовательности может быть автоматически выведен. В этом случае, это последовательность, содержащая строки.

Другой способ инициализации пустой последовательности - вызвать процедуру `newSeq`. Мы рассмотрим вызовы процедур в <<Процедуры, следующей главе>>, но пока просто знайте, что это также возможно:

[source]
----
var
  e = newSeq[int]() <1>
----
<1> Предоставление типа параметра внутри квадратных скобок позволяет процедуре знать, что она должна вернуть последовательность определенного типа. +
Частая ошибка - пропуск конечных `()`, которые должны быть включены.


Мы можем добавлять новые элементы в последовательность с помощью функции `add`, аналогично тому, как мы это делали со строками.
Для этого последовательность должна быть изменяемой (объявленной с помощью `var`), и добавляемый элемент должен быть того же типа, что и элементы в последовательности.

[source]
.seq.nim
----
include::{source-dir}/seq.nim[]
----
<1> Добавление нового элемента того же типа (char).
<2> Добавление другой последовательности, содержащей тот же тип.

[source, output]
----
@['x', 'y', 'z']
@['1', '2', '3', 'x', 'y', 'z']
----

Попытка передать разные типы в существующие последовательности приведет к ошибке:

[source]
----
var i = @[9, 8, 7]

i.add(9.81) # error <1>
g.add(i)    # error <2>
----
<1> Попытка добавить `float` к последовательности `int`.
<2> Попытка добавить последовательность `int` к последовательности `char`.

С учетом того что последовательности могут изменять свою длину во время выполнения, нам нужен способ узнать их длину.  Для этого мы можем использовать функцию `len`.

[source]
----
var i = @[9, 8, 7]
echo i.len

i.add(6)
echo i.len
----

[source, output]
----
3
4
----





== Индексация и срезы

Индексация позволяет нам получить конкретный элемент из контейнера по его индексу.
Думайте об индексе как о позиции внутри контейнера.

Nim, как и многие другие языки программирования, использует индексацию с нулевым основанием, что означает, что первый элемент в контейнере имеет индекс ноль, второй элемент имеет индекс один и так далее.

Если мы хотим получить элемент "с конца", это делается с помощью префикса `^`.
Последний элемент (первый с конца) имеет индекс `^1`. Второй с конца имеет индекс `^2` и так далее.
Синтаксис для индексации: `<container>[<index>]`.

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=1..4]
----
<1> Индексация с нулевым основанием: элемент с индексом 1 - это `b`.
<2> Получение последнего элемента.

[source, output]
----
b
e
----

{nbsp}

Срезы позволяют нам получить серию элементов за один вызов.
Он использует тот же синтаксис, что и диапазоны (введенные в <<Циклы, цикл for>>).

Если мы используем синтаксис `start .. stop`, оба конца включаются в срез.
Используя синтаксис `start ..< stop`, индекс `stop` не включается в срез.

Синтаксис для срезов: `<container>[<start> .. <stop>]`.

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=6..8]
----

[source, output]
----
@[a, b, c, d]
@[a, b, c]
----

Как индексация, так и срезы могут быть использованы для присвоения новых значений существующим изменяемым контейнерам и строкам.

[source]
.assign.nim
----
include::{source-dir}/assign.nim[]
----
<1> Массив длины 5 имеет индексы от нуля до четырех. Мы присвоим значение каждому элементу массива.
<2> Присваивание (изменение) второго элемента (индекс 1) последовательности.
<3> Изменение символов строки по индексам 8 и 9.


[source, output]
----
[0, 7, 14, 21, 28]
@['p', 'q', 'r']
Tom and Barry
----




== Кортежи

Оба контейнера, которые мы видели до сих пор, были однородными.
Кортежи, с другой стороны, содержат разнородные данные, т.е. элементы кортежа могут быть разных типов.
Аналогично массивам, кортежи имеют фиксированный размер.

Елементы кортежа заключены внутри круглых скобок.

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=1..3]
----
<1> Кортежи могут содержать поля разных типов. В этом случае: `string`, `int`, и `char`.

[source, output]
----
(Field0: "Banana", Field1: 2, Field2: 'c')
----


Мы можем также дать имена каждому полю в кортеже, чтобы различать их.
Это может быть использовано для доступа к элементам кортежа, вместо индексации

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=5..10]
----
<1> Изменение значения поля по индексу.
<2> Изменение значения поля по имени.

[source, output]
----
(name: "Apple", weight: 7, rating: 'c')
----





== Упражнения

1. Создайте пустой массив, который может содержать десять целых чисел.
    * Заполните этот массив числами 10, 20, ..., 100. (Подсказка: используйте циклы)
    * Выведите только элементы этого массива, которые находятся на нечетных индексах (значения 20, 40, ...).
    * Умножьте элементы на четных индексах на 5. Выведите измененный массив.

2. Повторите упражнение гипотеза Коллатца, но в этот раз вместо печати каждого шага добавляйте его в последовательность.
    * Выберите начальное число. Интересные выборы, среди прочего, это 9, 19, 25 и 27.
    * Создайте последовательность, единственным элементом которой является начальное число
    * Используя ту же логику, что и раньше, продолжайте добавлять элементы в последовательность до достижения 1
    * Выведите длину последовательности и саму последовательность

3. Найдите число в диапазоне от 2 до 100, которое приведет к самой длинной последовательности Коллатца.
    * Для каждого числа в заданном диапазоне вычислите его последовательность Коллатца
    * Если длина текущей последовательности больше предыдущей записи, сохраните текущую длину и начальное число как новую запись (вы можете использовать кортеж `(longestLength, startingNumber)` или две отдельные переменные)
    * Выведите начальное число, которое дает самую длинную последовательность, и ее длину